#define _CRT_SECURE_NO_WARNINGS 1//scanf是C语言标准的语言,scanf_s是vs编译器独自有的,这句代码的作用是不让他报这个错
#include <stdio.h>
#include <string.h>
//int main(){
//  //%c单个字符输出的意思。
//  //%s是输出字符串。
//	//%d,打印整形类型数据;
//	//%f,打印浮点类型数据;
//	//%p,打印地址形式
//	//const int sum = 0;//加const时是常量,不能被改变,相当于java的final
//	//int sun = 0;	
//	//scanf("%d%d", &sum, &sun);	
//	//int count = 0;
//	//count = sum + sun;
//	//printf("count = %d\n", count);
//	char str1[] ="abc";//字符串结束符为\0
//	char str2[] = { 'a','b','c' };//出现随机值知道随机出现\0
//	printf("%d", strlen(str1));//长度为3
//	printf("%d", strlen(str2));//长度为随机值
//	//转义字符
//	//./n换行
//	//./t表格符
//	//./?转义三字母符
//	//./ddd,(ddd,代表数字,其中将数字用八进制转成10进制,再使用ASCII编码进行编译)
//	return 0;
//}


//循环
//int main() {
//	int code = 0;
//	while (code<100)
//	{
//		printf("正在循环第%d次\n", code);
//		code++;
//	}
//	printf("跳出循环%d", code);
//	return 0;
//}

//操作符
//+,加
//-,减
//*,乘
//\/,除
//%,余
//int main() {
//	//<<,向左位移符
//	int a = 5;//00000000000000000000000000000101
//	int c = a<<1;//将a转成bit位即是32个bit位,并且将一串bit向左移动,后面补0;
//	printf("向左位移后的结果%d\n", c);//为10
//	//>>,向右位移符
//	int d = a >> 1;
//	printf("向右位移后的结果%d\n", d);//为2
//	//&,并与
//	int b = 2;
//	int k = a&b;
//	printf("并与的结果%d\n", k);//为0,二进制数组中0为假,1为真,只有两个都是真时才等于真
//	//|,或,两值对比如果存在真那就是真,否则就是假
//	int o = a | b;
//	printf("或的结果%d\n", o);//为7
//	//^,异或,相同的二进制位则为0.相异的二进制位则为1
//	int q = a^b;
//	printf("异或的结果是%d\n", q);//为7
//	return 0;
//}


//单目操作符
//双目操作符
//int main() {
//	//!反逻辑操作符
//	int a = 10;
//	printf("!反逻辑操作符%d\n", a);
//	printf("!反逻辑操作符%d\n", !a);//在c语言中0为假,非零为真,如果等于0则为假	
//	//sizeof(),计算变量/类型所占的空间大小
//	printf("sizeof()计算所占空间大小%d\n", sizeof(a));
//	return 0;
//}

//原码,补码,反码
//原码是直接输出真值;
//反码(解决负数的问题),反码是正数不变,负数符号位不变其余取反;
//补码(解决正负0的问题),补码是正数不变,负数符合位不变,其余取反,最后加1(在反码的基础上加一,而不是源码);
//计算机的数字运算没有减法,常识中减去一个数相当于加上一个负数,那计算机运算设计就容易了.
//但是在计算过程中先把反码进行相加减,再将反码转成源码输出显示
//在反码计算过程中如果一直进1,结果得出时需要加一(00000101+11111100+1 =00000010)5-3先转成5+(-3)
//由于计算机如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的.这也就是为何计算机内部不使用原码表示一个数
//int main() {
//	int a = 0;//a = 0;这个就是展示也就是源码0+1
//	//a的源码,00000000000000000000000000000000
//	//00000000000000000000000000000000 
//	int b = ~a;
//	//b的源码,11111111111111111111111111111111
//	//计算机在运算时用的是反码运算,补码储存,源码展示
//	//b在运算中的反码,10000000000000000000000000000000
//	//b在储存时的补码,10000000000000000000000000000001
//	printf("输出b的值%d\n", b);
//	return 0;
//}

//关键字
//auto 自动的,自动创建自动销毁函数或者变量一般都是默人不写
//int 也是定义有符号的变量,其实也是signed int的省略写法
//signed 定义有符号的变量
//unsigned 定义没有符号的变量
//break 结束循环
//case switch循环语句里面的条件语句
//const 定义常量,Java是final
//continue 跳出当前循环继续下一次循环
//extern 引用外部变量用的关键字
//register 未知
//static 静态的
//while

//extern int add(int,int);
//int main() {
//	int mun = add(10,20);
//	printf("%d\n", mun);
//	return 0;
//}

//宏函数的使用
//int Max(int x,int y) {
//	if (x>y) {
//		return x;
//	}
//	else
//	{
//		return y;
//	}
//}
//
//#define MAX(X,Y) (X>Y?X:Y)
//int main() {
//	int a = 20;
//	int b = 10;
//	int c = Max(a, b);
//	printf("普通调用%d\n",c);
//	int d = MAX(a, b);
//	printf("宏调用%d\n",d);
//	return 0;
//}


//指针变量
//int main() 
//{	
//	//int a = 10;
//	//int* p = &a;//获取a的地址的目的是方便获取a,那怎么去获取a呢
//	//*p = 20; //解引用操作符,将地址形式转成a的值
//	////&a,作用是在内存中取出a的地址,地址是怎么产生的电脑有32位64位的数据线,每根数据线通电时会产生正电1和负电0
//	////那么他们在通电时就会产生出一串二进制(2^32和2^64)数字的地址,内存中最小的单位是byte,int类型在32位机子上的数据占4个字节
//	////64位所占的为8个字节
//	//printf("%d\n", a);
//	char ch = 'a';
//	char* c = &ch;
//	printf("%d\n", sizeof(c));
//	return 0;
//}
//经过struct修饰的对象,又称为结构体,复杂对象
struct Book
{
	char name[10];
	short price;
};
//结构体,复杂对象
int main() {
	struct Book b1 = { "java基础",20 };
	struct Book* pd = &b1;
	//.结构体.成员变量
	//->结构体指针->成员变量
	printf("书名: %s\n", (*pd).name);
	printf("价格: %d\n", (*pd).price);
	strcpy(pd->name,"C语言");//重新赋值给char变量
	pd->price = 50;
	printf("书名: %s\n", pd->name);
	printf("价格: %d\n", pd->price);
	return 0;
}
